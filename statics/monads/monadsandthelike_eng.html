<html>
<head>
	<link rel="stylesheet" href="css/opstartsite.css"><br>
	<link rel="stylesheet" href="../../assets/css/tele2site.css" TYPE="text/css"">
	<title>
		Monads and the like
	</title>
	<link rel="stylesheet" href="/home/hans/Documenten/html/styles/default.css">
	<script src="/home/hans/Documenten/html/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>
<body bgcolor="lightgrey">
	<h1><a href="http://learnyouahaskell.com/chapters" target="_blank">Monads and the like</a><h1>
	<h3>What I understand about it now</h3>
	<div class="klein">(Renarks / additions welcome.)</div>
	
<ul>
<li>It is all about operations on elements (values or functions), often encapsulated in a structure, a <b>context</b>.<br>
List and Maybe/Option for instance have a compound "kind" (metatype): they need an other type for construction. That makes them the context of the other type.<br>
The operations succeed if those elements  or structures obey a number of laws.<br>
Those laws often result in primitives, typeclass-methods.
<li>There are five groups of elements or structures. They obey an increasing number of laws, <br>
- to which lesser and lesser elements abide.<br>
- by which more and more operations are made possible.<br>
<li>There is a cesure between Monoid en Functor (Functor  is not a strict subclass of Monoid). Some Monads or Functors can act like a Monoid.<br>
<i>The last remark is not strictly true: Monoids always are concrete types (they don't need a typeparameter, like with <b>Int</b>, or those parameters are filled in, like with <b>List Char</b>).<br>
A Functor (and consequently also a Monad) demands a parameter (is a context).</i>
</ul>

<h3>Laws</h3>
<div class="klein">In the following S is a set with an associated binary operation O.<br>
Some "synonyms" may concern the same operation, but belong to different levels. Ap in this way is the Monad-version of &lt;*&gt; (Functor-version).</div>
<ul>
<li><b>Closure</b>: Applying O to two elements of S results in an element of S again.
<li><b>Associativity</b>: When combining pairs of elements order doesn't matter.
<div class="klein">(The order of the elements may matter, like in string-concatenation, but not the order of the operations, the location of the parenthesis.<br>
So subtraction is not associatif, (5 - 3) - 4 != 5 - (3 - 4))</div>
<li><b>Identity</b> or  <b>zero</b><!-- of  <b>unit</b> of <b>return</b>-->: there is an identityelement with an identity operation resulting in the starting-element.<br>
(With addition for instance this is 0, with multiplication 1, when calculating a maximum -&infin;.)
<li><b>Compose</b>: f(g(a)) = f&bull;g(a)
<li><b>Pure</b>, <b>unit</b> or <b>return</b>: def pure[A] (a:A) : F[A]<!--Verbeterd-->
<li><b>&lt;*></b> or <b>ap</b>: def ap[A, B] (fa:F[A]) (fab: F[ A=>B ]) : F[B]<br>
override def map [A,B] (fa: F[A]) (fab: A => B): F[B]=ap(fa)(pure(fab))
<li><b>flatMap</b> (or <b>bind, >>=</b>)
</ul>


<h3>The benefits of Monads for the programmer</h3>
<div class="klein">I'm just talking about Monads here. It will be clear that in some cases it is sufficient for instance to be a Functor.</div>
<ul>
<li>Many standardtypes, like Lists in Haskell and Scala, are bulkcontainers, and often they are Monads too. The same may be the case for self-defined types like a Tree.<br> 
Operations on the componenten thereof are often easy to combine or join (composing or chaining).<br>
Other bulkoperations deliver an over-all result (reducing or folding).

<li>"Smaller" standardtypes (like Maybe/Option of Haskell/Scala respectively) can be used to  elegantly handle exceptional cases.<br> 
If a component doen't exist or results in an exception this can be ignored, or the whole bulkoperation can be cancelled without endless if-then-else, case- or try-catch constructions.
<li>Monads are also used to handle operations with side-effects. This may be about reporting intermediate results (logging), IO-operations, random-input or state-maintenance.<br>
In pure functional code this is all impossible (functions deliver clear-cut results based on their input and don't change anything in the outside world).<br> Monads however present ways around these problems by incorporating the side-effect in the context and taking care of it in the implementation of <b>>>=</b>.<br> 
Especially in Haskell this kind of code is clearly distinguishable from pure functional code. (In Scala it is possible to cheat, but in Haskell side-effects are limited to this kind of Monads.)<br> 
In Scala the for-expression or comprehension is the ideal syntax to handle Monads.
<li>Functional languages are characterized by a focus on data-flow in stead of control-flow, and also by the use of very eleborate standardlibraries with optimized standardfunctions<br> for standard datastructures(that are often Monads).<br> 
This in contrast with the OOP (Object Oriented Programming) way of building custom datastructures with custom operations.<br>
The pure functional part of the code is consisting of a bunch of definitions or equations without impact on the outer world (as is usage in math),<br> 
more then of a sequence of instructions and statements (changing mutable variables) as is usual in especially imperative, but also OOP-code.<br>
The code is still sequential, but focus is far less on on the order of the instructions, 
because definitions, once defined, are easely gathered by the compiler.<br> With lazy evaluation the order even becomes irrelevant.<br>
For this reason it is often said that a functional programmer is more describing the what then the how.<br>
</ul>

<font color="red"> Still translating.  Proceeded until here. Contact me if I have to hurry up.</font>

<hr size="5" noshade>
<br>
<table border="1" width="100%" bgcolor="white">
<tr valign="top">
	<th colspan="2">I. Semigroep</th>
</tr>
<tr>

	<td width="20%">
		Voorbeelden<br>
		<b>Constructor: *</b><br>
	</td>
	<td >
		Set gehele getallen met + of * operatie: (4 + 10) + 2 = 4 + (10 +2)<br>
		<div class="klein">Voorbeelden zonder identity: positieve gehele getallen met + operator, of niet-lege sequenties.</div>
 	</td>
</tr>
<tr>
	<td>
		Laws<br>
	</td>
	<td >
		<b>Closure</b> en <b>Associativity<br>
 	</td>

</tr>
<tr>

	<td>
		Operatie<br>
	</td>
	<td >
		append<br>
 	</td>

</tr>
</table>
<br>
<table border="1" width="100%" bgcolor="white">
<tr valign="top">
	<th colspan="2">II. Monoid</th>
</tr>
<tr>

	<td width="20%">
		Voorbeelden<br>
	</td>
	<td >
		Set gehele getallen met + of * operatie: a+0=a, a*1=a<br>
		Lists, Bool, Ordering, Maybe, zelfgedefinieerde Tree.
		<div class="klein">Verzameling met operatie, die je (recursief) kunt uitbreiden.</div>
	</td>

</tr>
<tr>

	<td>
		Laws
	</td>
	<td >
		Als Semigroep, met <b>Identity</b><br>
<ul>
    <li>mempty `mappend` x = x
    <li>x `mappend` mempty = x
    <li>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
</ul>
<i>(<b>mempty</b> vertegenwoordigt het identity-element voor een bepaalde monoid met operatie, <b>mappend</b> is de binaire functie.<br>
<b>mconcat</b> is een secundaire functie die een lijst monoids via een fold-operatie reduceert tot een enkele waarde.<br> mconcat is een ongelukkige naam, bij een optelling bijvoorbeeld wordt er niets aan elkaar geplakt.)</i>
	</td>

</tr>
<tr>

	<td>
		Operaties<br>
	</td>
	<td >
		Als Semigroep, aangevuld met de zero-operatie.<br>
	</td>

</tr>
</table>
<br><hr width="60%" size="5"><br>

<table border="1" width="100%" bgcolor="white">
<tr valign="top">
	<th colspan="2">III. Functor</th>
</tr>

<tr>
	<td width="20%">
		Voorbeelden<br>
		<b>Unary type constructor:&nbsp; *->*<br>
		Binary type constructor: *->*->*<br>
		Functor[F[_]]</b><br>
	</td>
	<td >
		<b>Scala:</b> List, Option, Set, Either, Try, Future... <br> 
		<b>Haskell:</b> List, Maybe, eigen Tree, Either, Function ...<br>
		<div class="klein">"Alles waarover gemapt kan worden", het toepassen van een functie op waarde[n] in een context.</div>
		<div class="klein">Mapping over een functie is functie-composition (<a href="http://nicholas.ren/2014/03/28/monad.html" target="_blank">Nicholas</a>, zie ook LYAH Functor)</div>
	</td>
</tr>
<tr>
	<td>
		Laws
	</td>
	<td >
		<b>Identity</b> en <b>Compose</b><br>
		<dl>
<dt>1. Indentity
<dd><b>fmap id = id</b>
<dt>2. Compose
<dd><b>fmap (f . g) = fmap f . fmap g</b> , oftewel<br>
<b>fmap (f . g) F = fmap f (fmap g F)</b>
</dl>
	</td>
</tr>
<tr>
	<td>
		Operatie
	</td>
	<td >
		E&eacute;n typeclass-methode: <b>fmap :: (a -> b) -> f a -> f b</b><br>
		(map is de List-implementatie van fmap)<br>
		<div class="klein">Map, Either, Function1 zijn binary, daarbij moet de operatie partieel, in stappen worden toegepast.</div>
	</td>
</tr>
</table>

<!------------------------------------------------------------------------------------------------------------------------------------------------------->
<br>
<table border="1" width="100%" bgcolor="white">
<tr valign="top">
	<th colspan="2">IV. Applicative (-Functor)</th>
</tr>
<tr>
	<td width="20%">
		Voorbeelden
	</td>
	<td >
		Voorlopig: De toegepaste functie kan zich zelf ook binnen een context bevinden<br>
	</td>
</tr>
<tr>
	<td>
		Laws
	</td>
	<td >
<ul>
<li>pure f &lt;*> x == fmap f x
<li>pure id &lt;*> v == v
<li>pure (.) &lt;*> u &lt;*> v &lt;*> w = u &lt;*> (v &lt;*> w)
<li>pure f &lt;*> pure x = pure (f x)
<li>u &lt;*> pure y = pure ($ y) &lt;*> u
</ul>
	</td>
</tr>
<tr>
	<td>
		Operaties
	</td>
	<td >
	Als Functor, met <b>Pure</b> <i>(Wrapt value in applicative),</i><br>
	en <b>ap</b> of <b>&lt;*&gt;</b><i>(Neemt een applicative met een functie er in en een andere applicative, extraheert de functie(s) uit de eerste en mapt die over de tweede).</i><br>
	Applicatives zijn composable, wat niet voor elke Monad zo is.<br>
	</td>
</tr>
</table>

<br>
<table border="1" width="100%" bgcolor="white">
<tr valign="top">
	<th colspan="2">V. Monad</th>
</tr>
<tr>
	<td width="20%">
		Voorbeelden<br>
		<b>Higher order type operator: (*->*)->*<br>
		Monad[M[_]]</b><br>
		<div class="klein">M[_] staat voor een unary type-constructor als List of Option</div>
	</td>
	<td >
		<b>Scala:</b> List, Option, Set, Either, Try, Future... <br> 
		<b>Haskell:</b> List, Maybe, Tree?, Either, ...<br>
		
		<div class="klein">"Informeel is een Monad alles met een constructor en een flatMap methode."</div>
		<!--Scala with Cats blz. 77.-->	</td>
</tr>
<tr>
	<td>
		Laws
	</td>
	<td >
<dl>
    <dt><b>Left identity</b>
    <dd><b>return x >>= f</b> is het zelfde als <b>f x</b>
    <dt><b>Right identity</b>
    <dd><b>m >>= return</b> is gelijk aan <b>m</b>
<dt><b>Associativity</b>
<dd>Het resultaat van <b>(m >>= f) >>= g</b> is gelijk aan dat van <b>m >>= (\x -> f x >>= g)</b>
 </dl>
	</td>
</tr>
<tr>
	<td>
		Operaties
<pre><code class="haskell">
class Applicative m => Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b
 
    (>>)   :: m a -> m b -> m b
    fail   :: String -> m a
</code></pre>
	</td>
	<td >
		Als Applicative, met <b>bind</b>, <b>>>=</b> of <b>do-notation</b>. (In Scala: <b>flatMap</b>.)<br><br>
		Naast <b>bind</b> dient <b>return</b> voor het wrappen van een waarde in de monad (een "lift"-functie, zoals <b>pure</b> bij de applicative), en <b>>></b> ("then") voor het chainen van monadische acties die het resultaat van de voorganger niet nodig hebben. 
		<b>fail</b> is alleen intern nodig voor pattern-match failures in do-notation.
	</td>
</tr>
</table>
<br><div class="klein">Net als de Applicative (-Functor) is ook Arrow een superclass van Monad, maar deze past niet helemaal in dit rijtje.
Arrows missen een andere law en hebben een ander toepassingsgebied (o.a. parsers).</div>

<br><br><br><br>

</body>
</html>

